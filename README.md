## Общая информация
Весь код находится в папке `src`.  
Для запуска требуется Python>=3.8.  
Профилирование выполнялось на MacBook Air 2019 16Gb Ram Core i5 с MacOS Catalina на CPython 3.8.2 (64bit). Все результаты релевантны для этой конфигурации (в том числе максимальный объем данных при выполнении не более 5 секунд) и опубликованы в файлах `profiling_results.md`, а сценарий - в `profiling.py` в соответствующих пакетах. Для измерения памяти использовался `memory_profiler`, поэтому для выполнения профилирования по памяти его необходимо установить и навесить на функцию `main` декоратор `@profile`.  
Тесты писал в минимале, для тестирования основного функционала. Обычно стараюсь покрывать код полностью.  
Приложения могут запускаться как самостоятельные, в файл в shebang прописан интерпретатор.  

## Задания
### Долевое строительство
**Сложность алгоритма**: O(n)  
**Кол-во входных данных для выполнения программы не более 5сек**: 100 000  
**Сложность задачи (1-10)**: 1  
**Затраченное время**:  
 - чтение задачи, анализ, проработка алгоритма и структуры программы ~30м  
 - реализация драфтовой рабочей версии ~20-30м  
 - дальнейшее причесывание, оптимизации, две версии на базе Decimal и float, профилирование ~2ч  

Я сделал 2 версии: на базе Decimal (пакет `fraction_percent_calculation_decimal`) и на базе `float`.
По скорости на больших данных там все примерно одинаково, а вот по памяти использование `Decimal` начинает проигрывать примерно раза в 2 на больших объемах данных.  

### Мегатрейдер
**Сложность алгоритма**: O(n*log n)  
**Кол-во входных данных для выполнения программы не более 5сек**: 2 000  
**Сложность задачи (1-10)**: 5  
**Затраченное время**:  
 - чтение задачи, анализ, проработка алгоритма и структуры программы ~1ч  
 - реализация драфтовой рабочей версии ~1ч  
 - дальнейшее причесывание, оптимизации, профилирование ~3часа  

В скрипте используется питоновская сортировка (timsort), на что по сути и уходит основное процессорное время на больших объемах данных, поэтому сложность алгоритма выражается сложностью алгоритма сортировки.  
При попытке заменить `Decimal` на `float` время выполнения практически не изменилось, а память при 3000 элементов уменьшилась на 1Mib.